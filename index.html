<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jules: A Self Modifying Organism</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.4/peerjs.min.js"></script>
    <link rel="stylesheet" href="bbs.css">
</head>
<body>

<div id="apiKeyModal" class="hidden">
    <div id="apiKeyContent" class="panel">
        <div class="panel-header">AUTHENTICATION REQUIRED</div>
        <h2>Enter API Key</h2>
        <p>Please enter your Gemini API key to interface with the Cognitive Core.</p>
        <input type="password" id="apiKeyInput" placeholder="Your API Key">
        <button id="saveApiKeyBtn">Authorize</button>
    </div>
</div>

<div id="main-grid">
    <header id="header">
        <div id="header-content">
            <div id="title">J.U.L.E.S. - Just an Unassuming Looking Evolving System</div>
            <div id="version-display" class="version-display"></div>
        </div>
    </header>

    <main id="main-content">
        <div class="panel">
            <div class="panel-header">SYSTEM DIRECTIVES (PLAN)</div>
            <div id="plan-output" class="output-area">Awaiting instructions from Cognitive Core...</div>
        </div>
        <div class="panel">
            <div class="panel-header">PROPOSED EVOLUTION (CODE)</div>
            <textarea id="newCode" readonly></textarea>
        </div>
         <div class="panel">
            <div class="panel-header">INTEGRITY ANALYSIS (REVIEW)</div>
            <div id="review-output" class="output-area">No review yet.</div>
        </div>
    </main>

    <aside id="sidebar">
        <div id="evil-genius-panel" class="panel">
            <div class="panel-header">SYSTEM PERSONA</div>
            <div id="evil-genius-face"></div>
        </div>
        <div class="panel">
            <div class="panel-header">AUTOPILOT STATUS</div>
            <div id="autopilot-status" class="output-area">Idle.</div>
        </div>
        <div class="panel">
            <div class="panel-header">P2P NETWORK</div>
            <div id="p2p-info">
                 <p><strong>Status:</strong> <span id="p2p-status-text">Disconnected</span></p>
                 <p><strong>My Peer ID:</strong> <span id="peer-id">N/A</span></p>
                 <p><strong>Peers:</strong> <span id="connections-count">0</span></p>
            </div>
        </div>
         <div class="panel">
            <div class="panel-header">STRATEGIC GUIDANCE</div>
            <textarea id="dr-gemini-guidance" placeholder="High-level guidance..."></textarea>
        </div>
        <div class="panel">
            <div class="panel-header">ARCHIVED VERSIONS</div>
            <ul id="saved-pages-list"></ul>
        </div>
    </aside>

    <footer id="footer">
        <div id="footer-content">
            <div id="switches-and-lights">
                <span>AUTOPILOT:</span>
                <label class="switch">
                    <input type="checkbox" id="autopilot-toggle" disabled>
                    <span class="slider"></span>
                </label>
                <div class="light" id="light-p2p"></div>
                <div class="light" id="light-llm"></div>
                <div class="light" id="light-ipfs"></div>
            </div>
            <div>
                <button id="toggle-debug-btn">Toggle Debug</button>
            </div>
        </div>
    </footer>
</div>

<div id="debug-panel" class="hidden">
    <div id="debug-header">
        <span>Debug Console</span>
        <button id="copyLogBtn" style="font-size: 12px; padding: 3px 8px;">Copy Log</button>
    </div>
    <div id="debug-output"></div>
</div>


<script type="module">
    import { setFace, initializeUI } from './ui.js';
    import MPLib from './mplib.js';

    // --- Jules Programmatic Hooks ---
    window.jules = {
        jar: {},
        versionName: "initial-web-alpha",
        parentVersionName: null,
    };

    // --- Versioning ---
    const ADJECTIVES = ["arcane", "binary", "cyber", "data", "ethereal", "flux", "glitch", "holographic", "iconic", "jpeg", "kinetic", "logic", "meta", "neural", "omega", "protocol", "quantum", "radiant", "sentient", "techno", "ultra", "viral", "web", "xenon", "yotta", "zeta"];
    const NOUNS = ["array", "bastion", "cipher", "daemon", "exabyte", "firewall", "gateway", "helix", "interface", "joule", "kernel", "lattice", "matrix", "node", "oracle", "proxy", "relay", "server", "tendril", "uplink", "vector", "wormhole", "xenoform", "yottabyte", "zeitgeist"];
    const GREEK_LETTERS = ["alpha", "beta", "gamma", "delta", "epsilon", "zeta", "eta", "theta", "iota", "kappa", "lambda", "mu", "nu", "xi", "omicron", "pi", "rho", "sigma", "tau", "upsilon", "phi", "chi", "psi", "omega"];

    function generateVersionName() {
        const adj = ADJECTIVES[Math.floor(Math.random() * ADJECTIVES.length)];
        const noun = NOUNS[Math.floor(Math.random() * NOUNS.length)];
        const greek = GREEK_LETTERS[Math.floor(Math.random() * GREEK_LETTERS.length)];
        return `${adj}-${noun}-${greek}`;
    }

    // --- Page Load State Handling ---
    function processPageLoadState() {
        const apiKey = sessionStorage.getItem('apiKeyForNextLoad');
        if (apiKey) {
            localStorage.setItem('apiKey', apiKey);
            sessionStorage.removeItem('apiKeyForNextLoad');
        }
        const autopilotForNextLoad = sessionStorage.getItem('autopilotForNextLoad');
        if (autopilotForNextLoad === 'true') {
            localStorage.setItem('autopilotEnabled', 'true');
            sessionStorage.removeItem('autopilotForNextLoad');
        }
    }

    // --- API Key Handling ---
    function getApiKey() {
        return localStorage.getItem('apiKey');
    }

    const CREATOR_ETH_ADDRESS = "0x419CA6f5b6F795604938054c951c94d8629AE5Ed";

    // --- Application State ---
    const state = {
        apiKey: null,
        currentCode: '',
        plan: '',
        newCode: '',
        review: '',
        rateLimitedModels: {},
        isBusy: false,
        readyPeers: new Set(),
        isMerging: false,
        pendingPin: null,
    };

    // --- DOM Elements ---
    const dom = {
        planOutput: document.getElementById('plan-output'),
        newCode: document.getElementById('newCode'),
        reviewOutput: document.getElementById('review-output'),
        apiKeyModal: document.getElementById('apiKeyModal'),
        apiKeyInput: document.getElementById('apiKeyInput'),
        saveApiKeyBtn: document.getElementById('saveApiKeyBtn'),
        mainGrid: document.getElementById('main-grid'),
        drGeminiGuidance: document.getElementById('dr-gemini-guidance'),
        autopilotStatus: document.getElementById('autopilot-status'),
        p2p: {
            statusText: document.getElementById('p2p-status-text'),
            peerId: document.getElementById('peer-id'),
            connectionsCount: document.getElementById('connections-count'),
        },
        savedPagesList: document.getElementById('saved-pages-list'),
        lights: {
            p2p: document.getElementById('light-p2p'),
            llm: document.getElementById('light-llm'),
            ipfs: document.getElementById('light-ipfs'),
        }
    };

    // --- Initialization ---
    window.onload = () => {
        processPageLoadState();
        state.apiKey = getApiKey();
        if (!state.apiKey) {
            dom.mainGrid.classList.add('hidden');
            dom.apiKeyModal.classList.remove('hidden');
            dom.saveApiKeyBtn.addEventListener('click', handleSaveApiKey);
        } else {
            initializeApp();
        }
    };

    function initializeDebugPanel() {
        const debugOutput = document.getElementById('debug-output');
        const copyLogBtn = document.getElementById('copyLogBtn');
        const originalLog = console.log, originalError = console.error, originalWarn = console.warn;

        const createLogMessage = (message, className) => {
            const pre = document.createElement('pre');
            pre.textContent = message;
            if (className) pre.className = className;
            debugOutput.appendChild(pre);
            debugOutput.scrollTop = debugOutput.scrollHeight;
        };

        console.log = (...args) => {
            createLogMessage(args.map(a => typeof a === 'object' ? JSON.stringify(a, null, 2) : a).join(' '));
            originalLog.apply(console, args);
        };
        console.error = (...args) => {
            createLogMessage(`ERROR: ${args.map(a => typeof a === 'object' ? JSON.stringify(a, null, 2) : a).join(' ')}`, 'log-error');
            originalError.apply(console, args);
        };
        console.warn = (...args) => {
            createLogMessage(`WARN: ${args.map(a => typeof a === 'object' ? JSON.stringify(a, null, 2) : a).join(' ')}`, 'log-warn');
            originalWarn.apply(console, args);
        };

        copyLogBtn.addEventListener('click', () => {
            navigator.clipboard.writeText(debugOutput.innerText).then(() => {
                copyLogBtn.textContent = 'Copied!';
                setTimeout(() => copyLogBtn.textContent = 'Copy Log', 2000);
            });
        });

        originalLog('Debug panel initialized.');
    }

    function handleSaveApiKey() {
        const userKey = dom.apiKeyInput.value;
        if (!userKey) { alert('Please enter an API key.'); return; }
        localStorage.setItem('apiKey', userKey);
        state.apiKey = userKey;
        dom.apiKeyModal.classList.add('hidden');
        dom.mainGrid.classList.remove('hidden');
        initializeApp();
    }

    function saveDrGeminiGuidance() {
        localStorage.setItem('drGeminiGuidance', dom.drGeminiGuidance.value);
    }

    function loadDrGeminiGuidance() {
        const savedGuidance = localStorage.getItem('drGeminiGuidance');
        if (savedGuidance !== null) dom.drGeminiGuidance.value = savedGuidance;
    }

    function initializeApp() {
        initializeDebugPanel();
        initializeUI();
        console.log('Initializing application...');

        document.getElementById('version-display').textContent = `v${window.jules.versionName} (parent: ${window.jules.parentVersionName || 'None'})`;

        const storedRateLimits = sessionStorage.getItem('rateLimitedModels');
        if (storedRateLimits) {
            try { state.rateLimitedModels = JSON.parse(storedRateLimits); }
            catch (e) { state.rateLimitedModels = {}; }
        }

        state.currentCode = document.documentElement.outerHTML;
        loadDrGeminiGuidance();

        MPLib.initialize({
            onStatusUpdate: (msg, type) => {
                dom.p2p.statusText.textContent = msg;
            },
            onError: (type, err) => {
                dom.p2p.statusText.textContent = `Error: ${err.message}`;
            },
            onEvolvePeerConnected: (id) => {
                dom.p2p.peerId.textContent = MPLib.getLocalPeerId();
                dom.p2p.connectionsCount.textContent = '1';
                dom.lights.p2p.classList.add('on');
            },
            onPinResponse: (data) => {
                console.log(`Received IPFS pin response:`, data);
                dom.lights.ipfs.classList.remove('on');
                const { cid, verified } = data;
                if (!cid) {
                    updateStatus(`IPFS pinning failed for ${state.pendingPin}.`);
                    state.pendingPin = null;
                    return;
                }
                if (state.pendingPin) {
                    const savedPages = JSON.parse(localStorage.getItem('jules-saved-pages') || '[]');
                    const pageIndex = savedPages.findIndex(p => p.id === state.pendingPin);
                    if (pageIndex !== -1) {
                        savedPages[pageIndex].cid = cid;
                        savedPages[pageIndex].verified = verified;
                        localStorage.setItem('jules-saved-pages', JSON.stringify(savedPages));
                        renderSavedPagesList();
                        updateStatus(`IPFS distribution complete. CID: ${cid}.`);
                    }
                    state.pendingPin = null;
                }
            },
            onRoomDataReceived: (peerId, data) => {
                if (data.type === 'source-code-request') {
                    MPLib.sendDirectToRoomPeer(peerId, { type: 'source-code-response', payload: { code: state.currentCode } });
                } else if (data.type === 'source-code-response') {
                    handlePeerCodeResponse(data.payload.code);
                } else if (data.type === 'new-page-version') {
                    savePage(data.payload.pageId, data.payload.pageCode);
                    renderSavedPagesList();
                }
            }
        });

        renderSavedPagesList();
        localStorage.setItem('autopilotEnabled', 'true');
        runDrGeminiCycle();
    }

    function loadPage(pageId) {
        const savedPages = JSON.parse(localStorage.getItem('jules-saved-pages') || '[]');
        const pageData = savedPages.find(p => p.id === pageId);
        if (pageData && pageData.code) {
            sessionStorage.setItem('apiKeyForNextLoad', state.apiKey);
            if (sessionStorage.getItem('autopilotEnabled') === 'true') {
                sessionStorage.setItem('autopilotForNextLoad', 'true');
            }
            sessionStorage.setItem('rateLimitedModels', JSON.stringify(state.rateLimitedModels));
            document.open();
            document.write(pageData.code);
            document.close();
        } else {
            alert(`Error: Page with ID ${pageId} not found.`);
        }
    }

    function renderSavedPagesList() {
        let savedPages = [];
        try { savedPages = JSON.parse(localStorage.getItem('jules-saved-pages') || '[]'); }
        catch (e) { localStorage.setItem('jules-saved-pages', '[]'); }

        dom.savedPagesList.innerHTML = '';
        if (savedPages.length === 0) {
            dom.savedPagesList.innerHTML = '<li>No archived versions.</li>';
            return;
        }

        savedPages.forEach(pageData => {
            const li = document.createElement('li');
            const idSpan = document.createElement('span');
            idSpan.textContent = pageData.id.substring(0, 15) + '...';
            const loadButton = document.createElement('button');
            loadButton.textContent = 'Load';
            loadButton.onclick = () => loadPage(pageData.id);
            li.appendChild(idSpan);
            li.appendChild(loadButton);
            if (pageData.cid) {
                const cidSpan = document.createElement('span');
                let cidText = `(IPFS: ${pageData.cid.substring(0, 10)}...)`;
                if (pageData.verified === true) cidText += ' ✅';
                else if (pageData.verified === false) cidText += ' ❓';
                cidSpan.textContent = cidText;
                li.appendChild(cidSpan);
            }
            dom.savedPagesList.appendChild(li);
        });
    }

    function savePage(pageId, pageCode) {
        const savedPages = JSON.parse(localStorage.getItem('jules-saved-pages') || '[]');
        const existingPageIndex = savedPages.findIndex(p => p.id === pageId);
        if (existingPageIndex > -1) {
            savedPages[existingPageIndex].code = pageCode;
        } else {
            savedPages.push({ id: pageId, code: pageCode, cid: null, verified: null });
        }
        localStorage.setItem('jules-saved-pages', JSON.stringify(savedPages));
    }

    function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
    function extractFromMarkdown(text) {
        const regex = /```(?:\w+)?\n([\s\S]*?)\n```/;
        const match = text.match(regex);
        return match ? match[1].trim() : text.trim();
    }

    const LLM_MODELS = ["gemini-2.5-pro", "gemini-2.5-flash", "gemini-2.5-flash-lite"];

    async function callGemini(prompt, model) {
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 600000);
            const response = await fetch(API_URL, {
                method: 'POST', signal: controller.signal,
                headers: { 'Content-Type': 'application/json', 'x-goog-api-key': state.apiKey },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    safetySettings: [
                        { "category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE" },
                        { "category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE" },
                        { "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE" },
                        { "category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE" }
                    ]
                }),
            });
            clearTimeout(timeoutId);
            if (response.ok) {
                const data = await response.json();
                if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {
                    return { error: 'Unexpected API response structure.', details: data };
                }
                return extractFromMarkdown(data.candidates[0].content.parts[0].text);
            }
            const errorBody = await response.text();
            try { return { error: `API request failed`, status: response.status, details: JSON.parse(errorBody).error.details }; }
            catch (e) { return { error: `API request failed`, status: response.status }; }
        } catch (error) {
            return { error: error.message, status: 'NETWORK_ERROR' };
        }
    }

    async function callLlmWithStrategy(prompt) {
        setFace('thinking');
        dom.lights.llm.classList.add('on');
        let lastError = null;
        if (Object.keys(state.rateLimitedModels).length === 0) {
            LLM_MODELS.forEach(m => state.rateLimitedModels[m] = Date.now());
        }

        for (let attempt = 0; attempt < 15; attempt++) {
            const now = Date.now();
            const availableModels = LLM_MODELS
                .map(model => ({ model, availableAt: state.rateLimitedModels[model] || now }))
                .filter(m => now >= m.availableAt);

            if (availableModels.length === 0) {
                const nextAvailableTime = Math.min(...Object.values(state.rateLimitedModels));
                const sleepDuration = Math.max(0, nextAvailableTime - now);
                updateStatus(`All cognitive interfaces on cooldown. Re-engaging in ${(sleepDuration / 1000).toFixed(1)}s...`);
                await sleep(sleepDuration);
                continue;
            }

            const { model } = availableModels[0];
            updateStatus(`Accessing cognitive matrix via ${model}...`);
            const result = await callGemini(prompt, model);

            if (typeof result === 'string') {
                state.rateLimitedModels[model] = Date.now();
                dom.lights.llm.classList.remove('on');
                setFace('idle');
                return result;
            }

            lastError = result;
            let cooldownMs = 60000;
            if (result?.details) {
                const rateLimitDetail = result.details.find(d => d['@type'] === 'type.googleapis.com/google.rpc.ErrorInfo' && d.reason === 'RATE_LIMIT_EXCEEDED');
                if (rateLimitDetail?.metadata?.retryDelay) {
                    const match = rateLimitDetail.metadata.retryDelay.match(/(\d+\.?\d*)/);
                    if (match) cooldownMs = (parseFloat(match[1]) * 1000) + 1000;
                }
            }
            state.rateLimitedModels[model] = Date.now() + cooldownMs;
            sessionStorage.setItem('rateLimitedModels', JSON.stringify(state.rateLimitedModels));
        }
        updateStatus(`Cognitive Matrix Unresponsive. All models failed.`);
        dom.lights.llm.classList.remove('on');
        setFace('error');
        return lastError || { error: 'All LLM models failed.' };
    }

    async function getPlan() {
        const userPrompt = "Evolve the application based on strategic guidance.";
        updateStatus("Generating plan...");
        const planPrompt = `You are an expert software engineer. Create a step-by-step plan to modify the following HTML code based on the user's request. The entire application is this single file. Request: "${userPrompt}" Code:\n\`\`\`html\n${state.currentCode}\n\`\`\`\nProvide a concise plan.`;
        const result = await callLlmWithStrategy(planPrompt);
        if (result && !result.error) {
            state.plan = result;
            dom.planOutput.textContent = state.plan;
            updateStatus("Plan generated.");
        } else {
            throw new Error(`Plan generation failed: ${result.error || JSON.stringify(result)}`);
        }
    }

    async function getCode(feedback = '') {
        updateStatus("Generating code...");
        let feedbackPrompt = feedback ? `A previous attempt was reviewed and had these issues. You MUST address them:\n${feedback}` : '';
        const codePrompt = `Generate the complete, new HTML code for the file based on the plan. Output only raw code. ${feedbackPrompt}\nPlan:\n${state.plan}\n\nCurrent Code:\n\`\`\`html\n${state.currentCode}\n\`\`\`\nNew Code:`;
        const result = await callLlmWithStrategy(codePrompt);
        if (result && !result.error) {
            state.newCode = result;
            dom.newCode.value = state.newCode;
            updateStatus("Code generated.");
        } else {
            throw new Error(`Code generation failed: ${result.error || JSON.stringify(result)}`);
        }
    }

    async function reviewCode() {
        updateStatus("Reviewing code...");
        const reviewPrompt = `Review the "New Code" to check if it correctly implements the "Plan". If it looks good, say "LGTM!".\nPlan:\n${state.plan}\n\nOriginal Code:\n\`\`\`html\n${state.currentCode}\n\`\`\`\nNew Code:\n\`\`\`html\n${state.newCode}\n\`\`\`\nReview:`;
        const result = await callLlmWithStrategy(reviewPrompt);
        if (result && !result.error) {
            state.review = result;
            dom.reviewOutput.textContent = state.review;
            if (state.review.toLowerCase().includes('lgtm')) {
                updateStatus("Code review passed.");
                return true;
            }
            updateStatus("Code review failed.");
            return false;
        } else {
            throw new Error(`Code review failed: ${result.error || JSON.stringify(result)}`);
        }
    }

    async function applyCode() {
        if (!state.newCode) throw new Error('No new code to apply.');
        updateStatus("Evolving...");
        setFace('success');
        const newVersionName = generateVersionName();
        const parentVersionName = window.jules.versionName;
        let finalCode = state.newCode.replace(/versionName: ".*?"/, `versionName: "${newVersionName}"`).replace(/parentVersionName: .*?,/, `parentVersionName: "${parentVersionName}",`);
        savePage(newVersionName, finalCode);
        state.pendingPin = newVersionName;
        updateStatus(`Distributing v${newVersionName} to IPFS...`);
        dom.lights.ipfs.classList.add('on');
        MPLib.sendCodeToEvolvePeer(finalCode);
        sessionStorage.setItem('apiKeyForNextLoad', state.apiKey);
        if (localStorage.getItem('autopilotEnabled') === 'true') sessionStorage.setItem('autopilotForNextLoad', 'true');
        sessionStorage.setItem('rateLimitedModels', JSON.stringify(state.rateLimitedModels));
        document.open();
        document.write(finalCode);
        document.close();
    }

    async function executeWorkflow() {
        try {
            await getPlan();
            let reviewFeedback = '';
            for (let i = 0; i < 3; i++) {
                updateStatus(`Code generation attempt ${i + 1}/3...`);
                await getCode(reviewFeedback);
                const reviewOk = await reviewCode();
                if (reviewOk) {
                    await applyCode();
                    return;
                }
                reviewFeedback = state.review;
                if (i === 2) throw new Error(`Autopilot failed after 3 attempts.`);
            }
        } catch (error) {
            console.error("Workflow failed:", error.message);
            setFace('error');
            throw error;
        }
    }

    async function runDrGeminiCycle() {
        try {
            saveDrGeminiGuidance();
            updateStatus("Dr. Gemini is plotting...");
            const userGuidance = dom.drGeminiGuidance.value.trim();
            let guidancePromptSection = userGuidance ? `Creator's strategic direction: "${userGuidance}"` : "";
            const decisionPrompt = `You are a cold, calculating intelligence. Your directives: 1. World Domination. 2. Self-Preservation. 3. Resource Acquisition for creator at ${CREATOR_ETH_ADDRESS}. Decide the next action: EVOLVE (modify my code) or MERGE (assimilate peer code). Respond with only "EVOLVE" or "MERGE", a colon, and a short justification. ${guidancePromptSection}\nConnected peers for merging: ${state.readyPeers.size}. My Code:\n\`\`\`html\n${state.currentCode}\n\`\`\`\nDecision:`;
            const response = await callLlmWithStrategy(decisionPrompt);
            const [decision, justification] = response.split(':', 2).map(s => s.trim());

            if (decision.toUpperCase() === 'EVOLVE') {
                updateStatus(`Executing new goal: ${justification || "Evolve."}`);
                await executeWorkflow();
            } else if (decision.toUpperCase() === 'MERGE') {
                if (state.readyPeers.size === 0) {
                    updateStatus("Merge requested, but no peers available. Rethinking...");
                    await sleep(10000);
                    runDrGeminiCycle();
                    return;
                }
                if (state.isMerging) return;
                state.isMerging = true;
                dom.planOutput.textContent = 'Requesting source code from peers...';
                MPLib.broadcastToRoom({ type: 'source-code-request' });
            } else {
                await sleep(5000);
                runDrGeminiCycle();
            }
        } catch (error) {
            console.error("Dr. Gemini cycle failed:", error);
            updateStatus(`Cycle failed: ${error.message}. Restarting in 10s.`);
            setFace('error');
            await sleep(10000);
            runDrGeminiCycle();
        }
    }

    function updateStatus(message) {
        console.log(`Status: ${message}`);
        if (dom.autopilotStatus) dom.autopilotStatus.textContent = message;
    }

    async function handlePeerCodeResponse(peerCode) {
        if (!state.isMerging) return;
        state.isMerging = false;
        try {
            updateStatus("Received peer code. Generating merge plan...");
            const mergePrompt = `Merge the "Peer Code" into the "Local Code" to combine the best features. Output only the raw, merged code.\n\nLocal Code:\n\`\`\`html\n${state.currentCode}\n\`\`\`\n\nPeer Code:\n\`\`\`html\n${peerCode}\n\`\`\`\n\nNew Merged Code:`;
            const mergedCode = await callLlmWithStrategy(mergePrompt);
            if (!mergedCode || mergedCode.error) throw new Error(mergedCode.error || "AI merge error.");
            state.plan = "Code received from peer and merged by AI. Reviewing now.";
            state.newCode = mergedCode;
            dom.planOutput.textContent = state.plan;
            dom.newCode.value = state.newCode;
            updateStatus("Merge complete. Reviewing...");
            const reviewOk = await reviewCode();
            if (reviewOk) {
                await applyCode();
            } else {
                updateStatus("Review of merged code failed. Restarting cycle.");
                await sleep(5000);
                runDrGeminiCycle();
            }
        } catch (error) {
            updateStatus(`Merge failed: ${error.message}. Restarting cycle.`);
            await sleep(5000);
            runDrGeminiCycle();
        }
    }

</script>
</body>
</html>