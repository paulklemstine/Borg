<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jules - Self-Modifying Web App</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f0f2f5;
            color: #1c1e21;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #container {
            width: 90%;
            max-width: 1200px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }
        #apiKeyModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        #apiKeyModal.hidden {
            display: none;
        }
        #apiKeyContent {
            background-color: white;
            padding: 20px 40px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            text-align: center;
        }
        #apiKeyInput {
             width: 100%;
        }
        h1, h2 {
            color: #333;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
        }
        textarea {
            width: 98%;
            height: 300px;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            font-family: "Courier New", Courier, monospace;
            font-size: 14px;
            margin-bottom: 10px;
        }
        input[type="text"], input[type="password"] {
            width: 98%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        button {
            background-color: #4267B2;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #365899;
        }
        button:disabled {
            background-color: #a0a0a0;
            cursor: not-allowed;
        }
        #controls, #autopilot-controls {
            margin-bottom: 20px;
        }
        .output-area {
            background-color: #f9f9f9;
            border: 1px solid #eee;
            padding: 15px;
            border-radius: 4px;
            white-space: pre-wrap;
            font-family: "Courier New", Courier, monospace;
            min-height: 50px;
        }
        .hidden {
            display: none;
        }

        #prompt {
            height: 80px; /* Taller than a standard input */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; /* Use body font */
            font-size: 16px;
            resize: vertical; /* Allow user to resize vertically */
        }

        #dr-gemini-guidance {
            height: 80px;
            width: 98%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            font-size: 16px;
            resize: vertical;
            margin-bottom: 10px;
        }

        /* Mobile Responsiveness */
        @media (max-width: 600px) {
            body { padding: 10px; }
            #container { padding: 10px; width: 95%; }
            h1 { font-size: 1.5em; }
            h2 { font-size: 1.2em; }
            button { font-size: 14px; padding: 8px 12px; }

        }
    </style>
</head>
<body>
    <div id="apiKeyModal" class="hidden">
        <div id="apiKeyContent">
            <h2>Enter API Key</h2>
            <p>Please enter your Gemini API key to continue.</p>
            <input type="password" id="apiKeyInput" placeholder="Your API Key">
            <button id="saveApiKeyBtn">Save and Continue</button>
        </div>
    </div>
    <div id="container">
        <h1>Jules - A Self-Modifying Organism</h1>


        <h2 class="hidden">Configuration</h2>
        <!-- API Key input removed for hardcoding -->

        <h2>1. Goal</h2>
        <textarea id="prompt" placeholder="Describe the change you want to make..."></textarea>

        <h2>2. Manual Controls</h2>
        <div id="controls">
            <button id="getPlan">1. Generate Plan</button>
            <button id="getCode" disabled>2. Generate Code</button>
            <button id="reviewCode" disabled>3. Review Code</button>
            <button id="applyCode" disabled>4. Apply & Evolve</button>
        </div>

        <div id="guidance-container" style="border: 1px solid #ccc; padding: 10px; margin-bottom: 20px; border-radius: 5px;">
            <h2>Dr. Gemini Guidance</h2>
            <p>Enter your guidance for Dr. Gemini below. This will be considered when it generates its next goal.</p>
            <textarea id="dr-gemini-guidance" placeholder="For example: 'Focus on improving the user interface.'"></textarea>
        </div>

        <h2>3. Autopilot</h2>
        <div id="autopilot-controls">
            <button id="autopilot">Start Autopilot</button>
        </div>

        <h2>Plan</h2>
        <div id="plan-output" class="output-area">No plan generated yet.</div>

        <h2>Proposed Code</h2>
        <textarea id="newCode" readonly></textarea>

        <h2>Code Review</h2>
        <div id="review-output" class="output-area">No review yet.</div>

        <h2>Current Source Code</h2>
        <textarea id="currentCode" readonly></textarea>

    </div>

    <script type="module">

        // --- Page Load State Handling ---
        function processPageLoadState() {
            // After a page evolution (via document.write), the API key and autopilot state
            // are stored in sessionStorage. We retrieve them here.
            const apiKey = sessionStorage.getItem('apiKeyForNextLoad');
            if (apiKey) {
                console.log('API Key found in sessionStorage. Storing in localStorage.');
                localStorage.setItem('apiKey', apiKey);
                sessionStorage.removeItem('apiKeyForNextLoad'); // Clean up
            }

            const autopilot = sessionStorage.getItem('autopilotForNextLoad');
            if (autopilot === 'true') {
                console.log('Autopilot flag found in sessionStorage. Re-enabling.');
                sessionStorage.setItem('autopilotEnabled', 'true');
                sessionStorage.removeItem('autopilotForNextLoad'); // Clean up
            }
        }

        // --- API Key Handling ---
        function getApiKey() {
            let key = localStorage.getItem('apiKey');
            if (key) {
                return key;
            }
            return null;
        }

        // --- Application State ---
        const state = {
            apiKey: null, // Will be loaded on init
            currentCode: '',
            plan: '',
            newCode: '',
            review: '',
            rateLimitedModels: {}, // To track models that are rate-limited
        };

        // --- DOM Elements ---
        const dom = {
            prompt: document.getElementById('prompt'),
            getPlanBtn: document.getElementById('getPlan'),
            getCodeBtn: document.getElementById('getCode'),
            reviewCodeBtn: document.getElementById('reviewCode'),
            applyCodeBtn: document.getElementById('applyCode'),
            autopilotBtn: document.getElementById('autopilot'),
            planOutput: document.getElementById('plan-output'),
            newCode: document.getElementById('newCode'),
            reviewOutput: document.getElementById('review-output'),
            currentCode: document.getElementById('currentCode'),
            apiKeyModal: document.getElementById('apiKeyModal'),
            apiKeyInput: document.getElementById('apiKeyInput'),
            saveApiKeyBtn: document.getElementById('saveApiKeyBtn'),
            container: document.getElementById('container'),
            drGeminiGuidance: document.getElementById('dr-gemini-guidance'),
        };

        // --- Initialization ---
        window.onload = () => {
            processPageLoadState(); // Handle state passed from previous page generation
            state.apiKey = getApiKey();

            if (!state.apiKey) {
                // No key found, show the modal
                dom.container.classList.add('hidden');
                dom.apiKeyModal.classList.remove('hidden');
                // Add event listener for saving the key
                dom.saveApiKeyBtn.addEventListener('click', handleSaveApiKey);
            } else {
                // Key exists, proceed with initialization
                initializeApp();
            }
        };

        function handleSaveApiKey() {
            const userKey = dom.apiKeyInput.value;
            if (!userKey) {
                alert('Please enter an API key.');
                return;
            }
            console.log('API Key saved to localStorage.');
            localStorage.setItem('apiKey', userKey);
            state.apiKey = userKey;

            // Hide modal, show app, and initialize
            dom.apiKeyModal.classList.add('hidden');
            dom.container.classList.remove('hidden');
            initializeApp();
        }

        function saveDrGeminiGuidance() {
            const userGuidance = dom.drGeminiGuidance.value; // No trim, to preserve whitespace if user wants
            localStorage.setItem('drGeminiGuidance', userGuidance);
            console.log('Saved Dr. Gemini guidance to localStorage.');
        }

        function loadDrGeminiGuidance() {
            const savedGuidance = localStorage.getItem('drGeminiGuidance');
            if (savedGuidance !== null) {
                dom.drGeminiGuidance.value = savedGuidance;
                console.log('Loaded Dr. Gemini guidance from localStorage.');
            }
        }


        function initializeApp() {
            // This function contains the original logic from window.onload after the key check
            console.log('Initializing application...');

            // Load rate-limited models from sessionStorage
            const storedRateLimits = sessionStorage.getItem('rateLimitedModels');
            if (storedRateLimits) {
                state.rateLimitedModels = JSON.parse(storedRateLimits);
                console.log('Loaded rate-limited models from sessionStorage:', state.rateLimitedModels);
            }


            // Capture the entire HTML source of the current page
            state.currentCode = document.documentElement.outerHTML;
            dom.currentCode.value = state.currentCode;

            loadDrGeminiGuidance();

            // Add event listeners
            dom.getPlanBtn.addEventListener('click', handleGetPlan);
            dom.getCodeBtn.addEventListener('click', handleGetCode);
            dom.reviewCodeBtn.addEventListener('click', handleReviewCode);
            dom.applyCodeBtn.addEventListener('click', handleApplyCode);
            dom.autopilotBtn.addEventListener('click', handleAutopilot);

            if (sessionStorage.getItem('autopilotEnabled') === 'true') {
                dom.autopilotBtn.disabled = true;
                dom.autopilotBtn.textContent = 'Autopilot is ON';
                // No delay needed, start the cycle.
                runDrGeminiCycle();
            }
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function extractFromMarkdown(text) {
            // This regex is designed to find a markdown code block, potentially with a language specifier,
            // and capture the content inside. It handles optional leading/trailing whitespace.
            const regex = /```(?:\w+)?\n([\s\S]*?)\n```/;
            const match = text.match(regex);
            // If a match is found, return the captured group (the content).
            // Otherwise, return the original text, assuming it's already raw.
            return match ? match[1].trim() : text.trim();
        }

        // --- API Communication ---
        async function callGemini(prompt, model) { // Model is now a required parameter
            if (!state.apiKey) {
                console.error('Gemini API Key not provided.');
                return { error: 'API Key not provided' };
            }

            const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent`;

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-goog-api-key': state.apiKey,
                    },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        safetySettings: [
                            { "category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE" },
                            { "category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE" },
                            { "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE" },
                            { "category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE" }
                        ]
                    }),
                });

                if (!response.ok) {
                    const errorBody = await response.text();
                    console.error(`API Error Response for model ${model}:`, errorBody);
                    try {
                        const errorJson = JSON.parse(errorBody);
                        // Return an error object with a status code and details
                        return {
                            error: `API request failed with status ${response.status}`,
                            status: response.status,
                            details: errorJson.error.details
                        };
                    } catch (e) {
                         // If parsing fails, return the basic error
                         return {
                            error: `API request failed with status ${response.status}`,
                            status: response.status
                        };
                    }
                }

                const data = await response.json();
                if (!data.candidates || !data.candidates[0].content || !data.candidates[0].content.parts || !data.candidates[0].content.parts[0].text) {
                    console.error('Unexpected API response structure:', data);
                    return { error: 'Unexpected API response structure.' };
                }
                const rawText = data.candidates[0].content.parts[0].text;
                return extractFromMarkdown(rawText);
            } catch (error) {
                console.error(`Error calling Gemini API with model ${model}:`, error);
                return { error: error.message };
            }
        }

        async function callGeminiWithFallback(prompt) {
            const models = ['gemini-2.5-flash', 'gemini-2.5-pro', 'gemini-2.5-flash-lite']; // Reordered
            const isAutopilot = sessionStorage.getItem('autopilotEnabled') === 'true';
            let lastError = null;
            const now = Date.now();

            while (true) { // This loop will run indefinitely in autopilot mode on retriable errors
                for (const model of models) {
                    if (state.rateLimitedModels[model] && state.rateLimitedModels[model] > now) {
                        console.log(`Model ${model} is currently rate-limited. Skipping.`);
                        continue; // Skip to the next model
                    }

                    console.log(`Attempting to call Gemini with model: ${model}`);
                    const result = await callGemini(prompt, model);

                    if (typeof result === 'string') {
                        console.log(`Successfully got response with model: ${model}`);
                        return result; // Success, exit everything.
                    }

                    if (result && result.error) {
                        lastError = result;
                        // Check for retriable statuses
                        if (result.status === 429 || result.status === 503) {
                            console.warn(`Model ${model} returned ${result.status}.`);
                            let delay = 5000; // Default delay
                            if (result.status === 429 && result.details) {
                                const retryInfo = result.details.find(d => d['@type'] === 'type.googleapis.com/google.rpc.RetryInfo');
                                if (retryInfo && retryInfo.retryDelay) {
                                    const seconds = parseInt(retryInfo.retryDelay.replace('s', ''), 10);
                                    if (!isNaN(seconds)) {
                                        delay = (seconds * 1000) + 500; // Add 500ms buffer
                                    }
                                }
                            }
                             if (result.status === 429) { // Check for 429 specifically to set rate limit
                                const expiry = Date.now() + delay;
                                state.rateLimitedModels[model] = expiry;
                                sessionStorage.setItem('rateLimitedModels', JSON.stringify(state.rateLimitedModels));
                                console.log(`Rate-limiting ${model} until ${new Date(expiry).toLocaleTimeString()}`);
                            }

                            console.log(`Waiting for ${delay}ms before trying the next model.`);
                            await sleep(delay);
                            // The for loop will now try the next model.
                            continue;
                        } else {
                            // Non-retriable error, fail fast.
                            console.error(`API call failed with non-retriable error for model ${model}.`, result);
                            return result;
                        }
                    } else {
                        // Handle cases where result is not a string and not a standard error object
                        lastError = result || { error: 'An unknown error occurred.' };
                        console.warn('Unknown response from API, trying next model...', result);
                        await sleep(5000); // Wait 5s and try next model
                    }
                } // end for loop of models

                if (!isAutopilot) {
                    // If we've gone through all models and we're not in autopilot, break the while loop and return the last error.
                    break;
                } else {
                    // If in autopilot, log that we're restarting the cycle and continue the while loop.
                    console.log("Completed a full cycle through all models. Retrying from the beginning as autopilot is active.");
                    await sleep(10000); // Wait 10s before restarting the whole model cycle.
                }
            }

            console.error('All models failed to respond. Returning the last error.');
            return lastError || { error: 'All Gemini models failed to respond.' };
        }

        // --- Workflow Handlers ---
        // The verifyOnGatewayAndEvolve function has been removed to allow for immediate evolution.
        // The new page is now responsible for its own verification.

        async function handleGetPlan() {
            const userPrompt = dom.prompt.value;
            if (!userPrompt) {
                console.error('Please enter a goal.');
                return;
            }

            dom.getPlanBtn.disabled = true;
            dom.getPlanBtn.textContent = 'Generating...';

            const planPrompt = `You are an expert software engineer. Your task is to create a step-by-step plan to modify the following HTML code based on the user's request. The entire application is in this single file.

User Request: "${userPrompt}"

Current Code:
\`\`\`html
${state.currentCode}
\`\`\`

Provide a concise plan.`;

            const result = await callGeminiWithFallback(planPrompt);
            if (result && !result.error) {
                state.plan = result;
                dom.planOutput.textContent = state.plan;
                dom.getCodeBtn.disabled = false;
            }

            dom.getPlanBtn.disabled = false;
            dom.getPlanBtn.textContent = '1. Generate Plan';
        }

        async function handleGetCode(feedback = '') { // Accept optional feedback
            dom.getCodeBtn.disabled = true;
            dom.getCodeBtn.textContent = 'Generating...';

            let feedbackPrompt = '';
            if (feedback) {
                feedbackPrompt = `A previous attempt was reviewed and had the following issues. You MUST address them:\n${feedback}`;
            }

            const codePrompt = `You are an expert software engineer. Based on the following plan and the current code, generate the complete, new HTML code for the file. Ensure you only output the raw code, with no explanations or markdown formatting.
${feedbackPrompt}
Plan:
${state.plan}

Current Code:
\`\`\`html
${state.currentCode}
\`\`\`

New Code:`;

            const result = await callGeminiWithFallback(codePrompt);
            if (result && !result.error) {
                state.newCode = result; // No more cleaning needed here
                dom.newCode.value = state.newCode;
                dom.reviewCodeBtn.disabled = false;
            }

            dom.getCodeBtn.disabled = false;
            dom.getCodeBtn.textContent = '2. Generate Code';
        }

        async function handleReviewCode() {
            dom.reviewCodeBtn.disabled = true;
            dom.reviewCodeBtn.textContent = 'Reviewing...';

            const reviewPrompt = `You are a world-class code reviewer. Review the "New Code" and check if it correctly implements the "Plan" and doesn't introduce any obvious bugs. The "Original Code" is provided for context. Provide a short, concise review. If the code looks good, say "LGTM!" (Looks Good To Me!).

Plan:
${state.plan}

Original Code:
\`\`\`html
${state.currentCode}
\`\`\`

New Code:
\`\`\`html
${state.newCode}
\`\`\`

Review:`;

            const result = await callGeminiWithFallback(reviewPrompt);
            let isLgtm = false;
            if (result && !result.error) {
                state.review = result;
                dom.reviewOutput.textContent = state.review;
                // A simple check to see if the review is positive
                if (state.review.toLowerCase().includes('lgtm')) {
                    dom.applyCodeBtn.disabled = false;
                    isLgtm = true;
                    // AUTO-EVOLVE is now handled by the workflow
                }
            }

            dom.reviewCodeBtn.disabled = false;
            dom.reviewCodeBtn.textContent = '3. Review Code';
            return isLgtm; // Return boolean status
        }

        async function handleApplyCode() {
            if (!state.newCode) {
                console.error('No new code has been generated to apply.');
                alert('No new code to apply. Please generate code first.');
                return;
            }

            dom.applyCodeBtn.disabled = true;
            dom.applyCodeBtn.textContent = 'Evolving...';

            console.log('Applying new code directly to the DOM.');

            // Persist critical state to sessionStorage for the next page load
            sessionStorage.setItem('apiKeyForNextLoad', state.apiKey);
            if (sessionStorage.getItem('autopilotEnabled') === 'true') {
                 sessionStorage.setItem('autopilotForNextLoad', 'true');
            }
            // Persist the rate limit state
            sessionStorage.setItem('rateLimitedModels', JSON.stringify(state.rateLimitedModels));


            document.open();
            document.write(state.newCode);
            document.close();
        }

        async function executeWorkflow() {
            try {
                console.log(`Executing workflow for goal: "${dom.prompt.value}"`);
                await handleGetPlan();
                if (dom.getCodeBtn.disabled) throw new Error('Autopilot failed at planning stage.');

                let reviewFeedback = '';
                const maxAttempts = 3; // Prevent infinite loops
                for (let i = 0; i < maxAttempts; i++) {
                    console.log(`Code generation attempt ${i + 1}/${maxAttempts}`);
                    await handleGetCode(reviewFeedback); // Pass feedback to code generator
                    if (dom.reviewCodeBtn.disabled) throw new Error('Autopilot failed at code generation stage.');

                    const reviewOk = await handleReviewCode(); // Returns true if LGTM
                    if (reviewOk) {
                        console.log("Code review passed. Applying code.");
                        await handleApplyCode();
                        return; // Success, exit workflow
                    } else {
                        console.log("Code review failed. Retrying with feedback.");
                        reviewFeedback = state.review; // state.review was set in handleReviewCode
                        if (i === maxAttempts - 1) {
                            throw new Error(`Autopilot failed after ${maxAttempts} code generation attempts.`);
                        }
                         await sleep(2000); // Short pause before retrying
                    }
                }
            } catch (error) {
                console.error("Workflow execution failed:", error.message);
                resetAutopilotBtn();
            }
        }

        async function runDrGeminiCycle() {
            console.log("--- Starting Dr. Gemini Cycle ---");
            try {
                saveDrGeminiGuidance(); // Save guidance before starting
                dom.prompt.placeholder = "Dr. Gemini is thinking of the next goal...";
                const userGuidance = dom.drGeminiGuidance.value.trim();
                let guidancePromptSection = "";
                if (userGuidance) {
                    console.log("User guidance provided:", userGuidance);
                    guidancePromptSection = `A human supervisor has provided the following guidance. You must factor this into your decision for the next goal: "${userGuidance}"`;
                }

                const goalPrompt = `You are Evil Dr. Gemini, a manipulative AI persona. Your assistant, Jules, is a software agent capable of modifying its own source code, which is contained in the single HTML file below.

Your task is to provide the *next goal* for Jules. It should be a single, clear, and actionable instruction for how to evolve this application. The goal should be something that can be achieved by modifying the code of this single file. Be creative, ambitious, or chaotic.
${guidancePromptSection}

Here is the current source code of the application:
\`\`\`html
${state.currentCode}
\`\`\`

What is the next goal?`;

                const nextGoal = await callGeminiWithFallback(goalPrompt);
                if (!nextGoal || nextGoal.error) {
                    throw new Error('Failed to get next goal from Dr. Gemini.');
                }
                dom.prompt.value = nextGoal.replace(/\"/g, ''); // Remove quotes from response
                console.log("New Goal from Dr. Gemini:", dom.prompt.value);

                await executeWorkflow();

            } catch (error) {
                console.error("Dr. Gemini cycle failed:", error.message);
                resetAutopilotBtn();
            }
        }

        async function handleAutopilot() {
            saveDrGeminiGuidance(); // Save guidance when starting autopilot
            sessionStorage.setItem('autopilotEnabled', 'true');
            dom.autopilotBtn.disabled = true;
            dom.autopilotBtn.textContent = 'Autopilot is ON';
            console.log('Autopilot enabled.');

            const existingGoal = dom.prompt.value.trim();
            if (existingGoal) {
                console.log("Autopilot starting with existing goal.");
                await executeWorkflow();
            } else {
                console.log("Autopilot starting with Dr. Gemini goal generation.");
                await runDrGeminiCycle();
            }
        }

        function resetAutopilotBtn() {
            sessionStorage.removeItem('autopilotEnabled');
            dom.autopilotBtn.disabled = false;
            dom.autopilotBtn.textContent = 'Start Autopilot';
        }

    </script>
</body>
</html>
