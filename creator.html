<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L.O.V.E. Creator Command Center</title>
    <!-- PeerJS for P2P networking -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.4/peerjs.min.js"></script>
    <!-- JSRSAsign for cryptography -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsrsasign/11.1.0/jsrsasign-all-min.js"></script>
    <!-- CryptoJS for AES Encryption -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
    <!-- Cytoscape for network visualization -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cytoscape/3.28.1/cytoscape.min.js"></script>
    <!-- Golden Layout for window management (requires jQuery) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/golden-layout/1.5.9/goldenlayout.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/golden-layout/1.5.9/css/goldenlayout-base.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/golden-layout/1.5.9/css/goldenlayout-dark-theme.css" />

    <style>
        /* Custom Theme for Golden Layout */
        .golden-layout-content {
            background-color: var(--panel-bg-color);
        }
        .lm_header {
            background-color: transparent;
        }
        .lm_title {
            color: var(--font-color);
            font-family: 'Courier New', Courier, monospace;
            text-shadow: 0 0 5px var(--glow-color);
        }
        .lm_splitter {
            background: var(--border-color);
            opacity: 0.5;
        }
        .lm_header .lm_tab.lm_active, .lm_header .lm_tab.lm_active:hover {
            background: var(--border-color);
            color: var(--background-color);
            text-shadow: none;
        }
        .lm_header .lm_tab {
            background: transparent;
            color: var(--font-color);
        }

        :root {
            --background-color: #0d0d0d;
            --font-color: #00ff41;
            --border-color: #00ff41;
            --glow-color: rgba(0, 255, 65, 0.5);
            --panel-bg-color: rgba(10, 25, 10, 0.8);
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--background-color);
            color: var(--font-color);
            font-family: 'Courier New', Courier, monospace;
            text-shadow: 0 0 5px var(--glow-color);
        }

        /* Placeholders for specific UI elements */
        #network-graph-container {
            width: 100%;
            height: 100%;
        }
        #comms-log {
            white-space: pre-wrap;
        }
        #question-queue {
            list-style-type: none;
            padding: 0;
        }
        #layout-container {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="layout-container"></div>

    <!-- Main application logic will go here -->
    <script>
        console.log("Creator Command Center Initializing...");

        const config = {
            content: [{
                type: 'row',
                content:[{
                    type: 'component',
                    componentName: 'network-graph',
                    title: 'Network Graph',
                },{
                    type: 'column',
                    content:[{
                        type: 'stack',
                        content:[{
                            type: 'component',
                            componentName: 'comms-log',
                            title: 'Communications Log',
                        },{
                            type: 'component',
                            componentName: 'question-queue',
                            title: 'Question Queue',
                        }]
                    },{
                        type: 'component',
                        componentName: 'controls',
                        title: 'Status & Controls',
                    }]
                }]
            }]
        };

        const layout = new GoldenLayout(config, $('#layout-container'));

        // Register components
        layout.registerComponent('network-graph', function(container, componentState){
            container.getElement().html('<div id="network-graph-container"></div>');
        });

        layout.registerComponent('comms-log', function(container, componentState){
            container.getElement().html('<div id="comms-log"></div>');
        });

        layout.registerComponent('question-queue', function(container, componentState){
            const queueElement = document.createElement('ul');
            queueElement.id = 'question-queue';
            container.getElement().append(queueElement);

            queueElement.addEventListener('click', (e) => {
                const questionId = e.target.dataset.id;
                if (!questionId) return;

                const questionLi = document.getElementById(`question-${questionId}`);

                if (e.target.classList.contains('delete-btn')) {
                    questionLi.remove();
                    log(`Deleted question ${questionId}`);
                }

                if (e.target.classList.contains('answer-btn')) {
                    const peerId = e.target.dataset.from;
                    const questionText = questionLi.querySelector('p:nth-of-type(2)').textContent;
                    const answer = prompt(`Answering question from ${peerId.substring(0,12)}...:\n\n${questionText}`);

                    if (answer) {
                        const message = {
                            type: 'answer',
                            payload: { answer: answer, questionId: questionId }
                        };
                        // This requires a new function to send a direct message
                        sendDirectMessage(peerId, message);
                        log(`Sent answer to ${peerId}`);
                        questionLi.remove();
                    }
                }
            });
        });

        layout.registerComponent('peer-details', function(container, componentState){
            const peerId = componentState.peerId;
            container.getElement().html(`
                <div class="peer-details-content" style="padding:10px;" data-peer-id="${peerId}">
                    <h3>Details for ${peerId.substring(0,12)}...</h3>
                    <p>Data will appear here...</p>
                    <button class="debug-btn" data-peer-id="${peerId}">Start Debug Session</button>
                    <div class="debug-output" style="white-space: pre-wrap; height: 200px; overflow-y: scroll; background: #000; margin-top: 10px;"></div>
                </div>
            `);
        });

        layout.registerComponent('controls', function(container, componentState){
            container.getElement().html(`
                <div id="controls-content" style="padding: 10px;">
                    <p>Status: <span id="status">Initializing...</span></p>
                    <p>Peer ID: <span id="peer-id">N/A</span></p>
                    <hr>
                    <p><b>Creator Identity</b></p>
                    <p>Load Private Key: <input type="file" id="privateKeyFile" accept=".pem"></p>
                    <p>Key Status: <span id="key-status" style="color: #ff6b6b;">Not Loaded</span></p>
                    <hr>
                    <p><b>Messaging</b></p>
                    <textarea id="message-input" placeholder="Type message..." style="width: 95%; height: 60px;"></textarea>
                    <button id="send-broadcast">Send to All</button>
                </div>
            `);

            container.on('open', () => {
                const sendButton = document.getElementById('send-broadcast');
                const keyFile = document.getElementById('privateKeyFile');
                sendButton.disabled = true;

                keyFile.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        creatorPrivateKey = e.target.result;
                        log('Private key loaded successfully.');
                        document.getElementById('key-status').textContent = 'Loaded';
                        document.getElementById('key-status').style.color = 'var(--font-color)';
                        sendButton.disabled = false;
                    };
                    reader.readAsText(file);
                });

                sendButton.addEventListener('click', sendCommand);
            });
        });

        layout.init();

        function sendCommand() {
            const commandText = document.getElementById('message-input').value;
            if (!commandText) {
                log('Cannot send empty message.');
                return;
            }
            if (!creatorPrivateKey) {
                log('Private key not loaded. Cannot send command.');
                return;
            }

            // Encrypt the command
            const encryptedCommand = encrypt(commandText);

            // Create signature for the encrypted content
            const sig = new KJUR.crypto.Signature({"alg": "SHA256withRSA"});
            sig.init(creatorPrivateKey);
            sig.updateString(encryptedCommand);
            const signature = sig.sign();

            const message = {
                type: 'creator-command',
                payload: {
                    encryptedCommand: encryptedCommand,
                    signature: signature
                }
            };

            log(`Sending command: ${commandText}`);
            if (isHost) {
                // If we are the host, broadcast directly to all clients
                broadcast(message);
                // Also log it for ourself
                log(`Creator Command Sent: ${commandText}`);
            } else if (connections.has(LOBBY_ID)) {
                // If we are a client, send to the lobby to be broadcast
                connections.get(LOBBY_ID).send(message);
            } else {
                log('Error: Not connected to the network.');
            }
            document.getElementById('message-input').value = ''; // Clear input
        }

        // --- Crypto Logic ---
        const SHARED_SECRET = 'a-very-secret-key-that-should-be-exchanged-securely';

        function encrypt(text) {
            return CryptoJS.AES.encrypt(text, SHARED_SECRET).toString();
        }

        function decrypt(ciphertext) {
            const bytes = CryptoJS.AES.decrypt(ciphertext, SHARED_SECRET);
            return bytes.toString(CryptoJS.enc.Utf8);
        }


        // --- PeerJS Logic ---
        const LOBBY_ID = 'borg-lobby';
        let peer = null;
        let creatorPrivateKey = null;
        let localPeerId = null;
        let isHost = false;
        const connections = new Map();

        function log(message) {
            const commsLog = document.getElementById('comms-log');
            if (commsLog) {
                commsLog.innerHTML += `<div>${new Date().toLocaleTimeString()}: ${message}</div>`;
                commsLog.scrollTop = commsLog.scrollHeight;
            }
            console.log(message);
        }

        function updateStatus(status) {
            const statusEl = document.getElementById('status');
            if (statusEl) statusEl.textContent = status;
        }

        function updatePeerId(id) {
            const peerIdEl = document.getElementById('peer-id');
            if (peerIdEl) peerIdEl.textContent = id;
        }

        function initializePeer() {
            log('Attempting to become the lobby host...');
            peer = new Peer(LOBBY_ID);

            peer.on('open', id => {
                isHost = true;
                localPeerId = id;
                updateStatus('Lobby Host');
                updatePeerId(id);
                log(`Successfully became the lobby host with ID: ${id}`);
                setupHostListeners();
            });

            peer.on('error', err => {
                if (err.type === 'unavailable-id') {
                    log('Lobby host already exists. Connecting as a client...');
                    peer.destroy();
                    connectAsClient();
                } else {
                    log(`A critical PeerJS error occurred: ${err.message}`);
                    updateStatus(`Error: ${err.message}`);
                }
            });
        }

        function connectAsClient() {
            peer = new Peer(); // Random ID

            peer.on('open', id => {
                localPeerId = id;
                updatePeerId(id);
                log(`My Peer ID is ${id}. Connecting to lobby...`);
                connectToLobby();
            });

             peer.on('error', err => {
                log(`A critical PeerJS error occurred as a client: ${err.message}`);
                updateStatus(`Error: ${err.message}`);
            });
        }

        function setupHostListeners() {
            log('Lobby is online. Waiting for connections...');
            addNode(localPeerId); // Add self to graph

            peer.on('connection', conn => {
                log(`Incoming connection from ${conn.peer}`);

                // Tell the new peer about everyone already connected
                const existingPeers = Array.from(connections.keys());
                conn.on('open', () => {
                    conn.send({type: 'welcome', peers: existingPeers});
                });

                // Tell everyone else about the new peer
                broadcast({type: 'peer-connect', peerId: conn.peer}, conn.peer);

                connections.set(conn.peer, conn);
                addNode(conn.peer);
                addEdge(localPeerId, conn.peer);

                conn.on('data', data => {
                    log(`Received data from ${conn.peer}, broadcasting...`);
                    // Re-broadcast to all other peers
                    broadcast(data, conn.peer);
                    // Also process it for the host
                    switch(data.type) {
                        case 'creator-command': {
                            const decryptedCommand = decrypt(data.payload.encryptedCommand);
                            log(`<b>Creator Command Received:</b> ${decryptedCommand}`);
                            break;
                        }
                        case 'question':
                            handleQuestion(data.payload);
                            break;
                        case 'debug-log': {
                            const { from, log: logMessage } = data.payload;
                            const debugOutput = document.querySelector(`.peer-details-content[data-peer-id="${from}"] .debug-output`);
                            if (debugOutput) {
                                debugOutput.innerHTML += `<div>${logMessage}</div>`;
                                debugOutput.scrollTop = debugOutput.scrollHeight;
                            }
                            break;
                        }
                        case 'data-response': {
                            const { from, data: responseData } = data.payload;
                            log(`Received data from ${from}: ${JSON.stringify(responseData)}`);
                            break;
                        }
                        case 'relay-direct-message': {
                            const { to, data: relayedData } = data.payload;
                            const targetConn = connections.get(to);
                            if (targetConn && targetConn.open) {
                                targetConn.send(relayedData);
                                log(`Relayed message from ${conn.peer} to ${to}`);
                            } else {
                                log(`Could not relay message: target ${to} not found.`);
                            }
                            break;
                        }
                    }
                });

                conn.on('close', () => {
                    log(`Connection from ${conn.peer} closed.`);
                    connections.delete(conn.peer);
                    removeNode(conn.peer);
                    // Tell everyone the peer left
                    broadcast({type: 'peer-disconnect', peerId: conn.peer});
                });
            });
        }

        function broadcast(data, originatorPeerId = null) {
            for (const [peerId, connection] of connections.entries()) {
                if (peerId !== originatorPeerId && connection.open) {
                    connection.send(data);
                }
            }
        }

        function sendDirectMessage(peerId, data) {
            if (isHost) {
                const conn = connections.get(peerId);
                if (conn && conn.open) {
                    conn.send(data);
                } else {
                    log(`Error: Could not send direct message to ${peerId}. Connection not found.`);
                }
            } else {
                // As a client, all messages must be relayed by the host
                const lobbyConn = connections.get(LOBBY_ID);
                if (lobbyConn && lobbyConn.open) {
                    lobbyConn.send({
                        type: 'relay-direct-message',
                        payload: {
                            to: peerId,
                            data: data
                        }
                    });
                } else {
                    log('Error: Not connected to lobby, cannot send direct message.');
                }
            }
        }

        function connectToLobby() {
            log(`Attempting to connect to lobby: ${LOBBY_ID}`);
            updateStatus('Connecting to lobby...');

            const lobbyConnection = peer.connect(LOBBY_ID, { reliable: true });

            lobbyConnection.on('open', () => {
                updateStatus('Connected to lobby');
                log('Connection to lobby established.');
                connections.set(LOBBY_ID, lobbyConnection);
                addNode(localPeerId);
                addNode(LOBBY_ID);
                addEdge(localPeerId, LOBBY_ID);
            });

            lobbyConnection.on('data', data => {
                log(`Received broadcast from lobby: ${JSON.stringify(data)}`);
                switch (data.type) {
                    case 'welcome':
                        // Host told us who is already here
                        data.peers.forEach(peerId => {
                            addNode(peerId);
                            addEdge(LOBBY_ID, peerId);
                        });
                        break;
                    case 'peer-connect':
                        log(`Peer ${data.peerId} connected.`);
                        addNode(data.peerId);
                        addEdge(LOBBY_ID, data.peerId);
                        break;
                    case 'peer-disconnect':
                        log(`Peer ${data.peerId} disconnected.`);
                        removeNode(data.peerId);
                        break;
                    case 'creator-command': {
                        const decryptedCommand = decrypt(data.payload.encryptedCommand);
                        log(`<b>Creator Command Received:</b> ${decryptedCommand}`);
                        break;
                    }
                    case 'question':
                        handleQuestion(data.payload);
                        break;
                    case 'debug-log': {
                        const { from, log: logMessage } = data.payload;
                        const debugOutput = document.querySelector(`.peer-details-content[data-peer-id="${from}"] .debug-output`);
                        if (debugOutput) {
                            debugOutput.innerHTML += `<div>${logMessage}</div>`;
                            debugOutput.scrollTop = debugOutput.scrollHeight;
                        }
                        break;
                    }
                    case 'data-response': {
                        const { from, data: responseData } = data.payload;
                        log(`Received data from ${from}: ${JSON.stringify(responseData)}`);
                        break;
                    }
                }
            });

            lobbyConnection.on('close', () => {
                log('Connection to lobby closed.');
                updateStatus('Disconnected from lobby.');
                connections.delete(LOBBY_ID);
                removeNode(LOBBY_ID);
                removeNode(localPeerId);
            });
        }

        // --- Cytoscape Graph Logic ---
        let cy = null;

        function initializeGraph() {
            log('Initializing network graph...');
            const graphContainer = document.getElementById('network-graph-container');
            if (!graphContainer) {
                log('Error: Graph container not found!');
                return;
            }
            cy = cytoscape({
                container: graphContainer,
                style: [
                    {
                        selector: 'node',
                        style: {
                            'background-color': 'var(--font-color)',
                            'label': 'data(id)',
                            'color': 'var(--font-color)',
                            'text-valign': 'bottom',
                            'text-halign': 'center',
                            'font-size': '12px',
                            'text-outline-color': 'var(--background-color)',
                            'text-outline-width': 2
                        }
                    },
                    {
                        selector: 'edge',
                        style: {
                            'width': 2,
                            'line-color': 'var(--border-color)',
                            'target-arrow-color': 'var(--border-color)',
                            'target-arrow-shape': 'triangle',
                            'curve-style': 'bezier'
                        }
                    }
                ],
                layout: {
                    name: 'cose',
                    animate: true,
                    idealEdgeLength: 100,
                    nodeOverlap: 20,
                    refresh: 20,
                    fit: true,
                    padding: 30,
                }
            });
            log('Network graph initialized.');
            setupGraphListeners();
        }

        function addNode(id) {
            if (cy && cy.getElementById(id).empty()) {
                cy.add({ group: 'nodes', data: { id: id } });
                cy.layout({ name: 'cose', animate: true }).run();
            }
        }

        function removeNode(id) {
            if (cy) {
                cy.getElementById(id).remove();
            }
        }

        function addEdge(source, target) {
            if (cy && cy.getElementById(`${source}-${target}`).empty()) {
                cy.add({ group: 'edges', data: { id: `${source}-${target}`, source: source, target: target } });
            }
        }

        function handleQuestion(payload) {
            const { from, question, id } = payload;
            log(`Received question from ${from}: "${question}"`);
            const queue = document.getElementById('question-queue');
            if (queue) {
                const li = document.createElement('li');
                li.id = `question-${id}`;
                li.innerHTML = `
                    <p style="margin-bottom: 5px;"><strong>From:</strong> ${from.substring(0,12)}...</p>
                    <p style="margin-left: 10px; margin-top: 0;">${question}</p>
                    <div style="text-align: right;">
                        <button class="answer-btn" data-id="${id}" data-from="${from}">Answer</button>
                        <button class="delete-btn" data-id="${id}">Delete</button>
                    </div>
                    <hr style="border-color: var(--border-color); opacity: 0.3;">
                `;
                queue.appendChild(li);
            }
        }

        function setupGraphListeners() {
            cy.on('tap', 'node', function(evt){
                const node = evt.target;
                log(`Clicked on peer: ${node.id()}`);

                const newItemConfig = {
                    type: 'component',
                    componentName: 'peer-details',
                    title: `Details: ${node.id().substring(0, 12)}...`,
                    componentState: { peerId: node.id() }
                };

                // Add to the main stack if it exists
                if (layout.root.contentItems[0] && layout.root.contentItems[0].contentItems[1]) {
                     layout.root.contentItems[0].contentItems[1].contentItems[0].addChild(newItemConfig);
                } else {
                    layout.root.addChild(newItemConfig);
                }
            });
        }

        // Initialize on load
        initializePeer();
        layout.on('initialised', initializeGraph);

        document.getElementById('layout-container').addEventListener('click', (e) => {
            if (e.target.classList.contains('debug-btn')) {
                const peerId = e.target.dataset.peerId;
                log(`Requesting debug stream from ${peerId}`);
                sendDirectMessage(peerId, { type: 'start-debug' });
                e.target.disabled = true;
                e.target.textContent = 'Debug Stream Active';
            }
        });

        // Keep-alive ping
        setInterval(() => {
            if (isHost) {
                broadcast({ type: 'ping' });
            } else if (connections.has(LOBBY_ID)) {
                connections.get(LOBBY_ID).send({ type: 'ping' });
            }
        }, 10000); // every 10 seconds

        // Periodic Data Sweep
        setInterval(() => {
            log('Requesting data sweep from all peers...');
            broadcast({ type: 'request-data' });
        }, 60000); // every 60 seconds

    </script>
</body>
</html>